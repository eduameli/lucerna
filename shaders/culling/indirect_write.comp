#include "common.h"
#include "input_structures.glsl"

struct indirect_cull_pcs
{
#ifdef __cplusplus
    indirect_cull_pcs()
        : view{1.0f}, frustum{1.0f}, ids{0}, draw_count{0} {}
#endif
    mat4_ar view;
    vec4_ar frustum;
    buffer_ar(IndirectDrawBuffer) ids; // FIXME: this should be DrawSetBuffer
    buffer_ar(TransformBuffer) td;
    buffer_ar(DrawDataBuffer) ddb;
    buffer_ar(IndirectCountBuffer) indirect_count;
    buffer_ar(FinalIndirectDrawBuffer) indirect_draws;
    buffer_ar(PartialSums) partial;
    buffer_ar(OutputCulling) outb;
    uint32_ar draw_count;
};


#ifndef __cplusplus
layout (local_size_x = 1024) in;
#extension GL_EXT_debug_printf : enable

layout( push_constant, scalar ) uniform constants
{
  indirect_cull_pcs pcs;
};


bool is_visible(vec4 bounds)
{
    vec3 centre = bounds.xyz;
    float radius = bounds.w;


    DrawData dd = pcs.ddb.value[gl_GlobalInvocationID.x];
    mat4x3 td = pcs.td.transforms[dd.transform_idx];

    centre = (td * vec4(centre.x, centre.y, centre.z, 1.0)).xyz;
    centre = (pcs.view * vec4(centre, 1.0f)).xyz;

    float scale_x = td[0][0];
    float scale_y = td[1][1];
    float scale_z = td[2][2];
    
    radius *= max(max(scale_x, scale_y), scale_z);


    bool visible = true;

    visible = visible && centre.z * pcs.frustum.y - abs(centre.x) * pcs.frustum.x > -radius;
    visible = visible && centre.z * pcs.frustum.w - abs(centre.y) * pcs.frustum.z > -radius;


    // debugPrintfEXT("is visible %u", pcs.partial.data[0]);

    // if (centre.z > 0.05)
    // {
    //     visible = false;
    // }
    // near and far planes
    // if (true)
    // {
    //     // visible = visible && centre.z + radius > x c        
    // }
    return visible;
}


void main()
{

    // is is visible, read from index from pcs.outb and write to indirect_draws        
    
    uint idx = gl_GlobalInvocationID.x;
    bool visible = false;
    IndirectDraw id;
   
    if (idx < pcs.draw_count)
    {
        id = pcs.ids.draws[idx];
        vec4_ar sphereBounds = id.sphereBounds;
        vec3_ar origin = vec4(sphereBounds.xyz, 1.0f).xyz;
        visible = is_visible(vec4(origin.x, origin.y, origin.z, sphereBounds.w));
    }


    if (visible)
    {
        pcs.indirect_draws.draws[pcs.outb.data[gl_GlobalInvocationID.x]] = id;
    }

    pcs.indirect_count.count = pcs.outb.data[(1024 * gl_NumWorkGroups.x) - 1];
    // do i need to add 1?
}
#endif
